'''module to prepare PyCHAM for partitioning coefficient calculation (particle and wall)'''

# module responsible for preparing inputs to the calculation of the gas-particle 
# partitioning coefficient in kimt_calc

import numpy as np
import scipy.constants as si

def kimt_prep(y_mw, TEMP, num_speci, testf, Cw, act_wi, act_w, accom_coeff_ind, 
			accom_coeff_user, spec_namelist, num_sb):
	
	# ------------------------------------------------------------------
	# inputs:
	# y_mw - molecular weight of components (g/mol) (num_speci,1)
	# TEMP - temperature (K)
	# num_speci - number of components
	# testf - flag for whether in normal mode (0) or testing mode (1)
	# Cw - effective absorbing mass of wall (g/m3 (air))
	# act_wi - index of components with activity coefficients for the wall stated in act_w
	# act_w - activity coefficients for the wall of components whose index given in act_wi
	# accom_coeff_ind - index of components with accommodation coefficient set by the user
	# accom_coeff_user - accommodation coefficient set by the user
	# spec_namelist - names of components as stated in the chemical scheme
	# num_sb - number of size bins (excluding wall)
	# -----------------------------------------------------------------
	
	if testf == 1: # if in testing mode (for test_front.py)
		return(0,0,0,0,0,0,0) # return dummies
	
	surfT = 72.0 # assume surface tension of water (g/s2==mN/m==dyn/cm) for all particles
	# molecular diffusion coeffficient of each species in air (m2/s) 
	# Equation from JL Schnoor, Environmental Modelling: fate and transport of pollutants 
	# in water, air and soil, 1996, ISBN : 0471124362, page 331.
	# Note that no reference given in this text book for this equation, but results for
	# Xe and Kr are within 10 % of those calculated independently in Table 16.1 of 
	# Jacobson (2005)
	# Scale by 1e-4 to convert from cm2/s to m2/s
	DStar_org = (1.9E0*(y_mw**(-2.0E0/3.0E0)))*1e-4
	
	# mean thermal speed of each molecule (m/s) (11.151 Jacobson 2005)
	# note that we need the weight of one molecule, which is why y_mw is divided by
	# Avogadro's constant, and we need it in kg, which is why we multiply by 1e-3
	therm_sp = (np.power((8.0E0*si.k*TEMP)/(np.pi*(y_mw/si.N_A)*1.0E-3), 0.5E0))
	
	# mean free path (m) for each species (16.23 of Jacobson 2005)
	# molecular weight of air (28.966 g/mol taken from table 16.1 Jacobson 2005)
	mfp = (((64.0*DStar_org)/(5*np.pi*therm_sp))*(28.966/(28.966+y_mw))).reshape(-1, 1)

	# accommodation coefficient of components in each size bin
	accom_coeff = np.ones((num_speci, num_sb))*1.0e0
	
	# list containing accommodation coefficients that are functions
	accom_coeff_func = []
	# check for any accommodation coefficients set by user
	if len(accom_coeff_ind)>0:
		for i in range(len(accom_coeff_ind)):
			
			# get index of component stated
			ac_indx = spec_namelist.index(accom_coeff_ind[i].strip())
			
			# ensure it's a constant (not a function, which would be a string)
			if isinstance(accom_coeff_user[i], str)==False:
				accom_coeff[ac_indx] = accom_coeff_user[i]
			# if it is a function, it will be a string and needs making available to the 
			# kimt_calc module
			if isinstance(accom_coeff_user[i], str)==True:
				accom_coeff_func.append(str('accom_coeff[' + str(ac_indx) + ',:]' + ' = ' + accom_coeff_user[i]))
	
	# generate module that contains any accommodation coefficient functions, note, do 
	# this even if no functions supplied so that the accomm_coeff_calc is updated and
	# accurate for this simulation
	f = open('PyCHAM/accom_coeff_calc.py', mode='w')
	f.write('\'\'\'module for calculating accommodation coefficients, automatically generated by kimt_prep\'\'\'\n')
	f.write('\n')
	f.write('# code that expresses and performs the functions for accommodation \n')
	f.write('# coefficients that are given by the user in the model variables file \n')
	f.write('# and that are intended to be calculated real-time via the kimt_calc \n')
	f.write('# module \n')
	f.write('\n')

	# following part is the function (there should be an indent at the start of each line
	# following the def line - suggest using 1 tab)
	f.write('def accom_coeff_func(accom_coeff, radius):\n')
	f.write('\n')
	f.write('	# ------------------------------------------------------------------ \n')
	f.write('	# inputs:\n')
	f.write('	# accom_coeff - array containing accommdotion coefficients for all \n')
	f.write('	# components\n')
	f.write('	# radius - radii of size bins (m)\n')
	f.write('	# ------------------------------------------------------------------ \n')
	f.write('\n')
	f.write('	# calculate accommodation coefficients \n')
	# code to calculate accommodation coefficients as given by user 
	for line in accom_coeff_func:
		f.write('	%s \n' %line)
	f.write('\n')
	f.write('	return accom_coeff\n')
	f.close()
	
	# activity coefficient of components
	act_coeff = np.ones((num_speci, 1))*1.0e0
	if len(act_wi)>0: # user-defined activity coefficients for wall
		act_coeff[act_wi] = act_w

	# convert Cw (effective absorbing mass of wall) from g/m3 (air) to 
	# molecules/cc (air), assuming a molecular weight of 200g/mol (*1.0e-6 to convert from
	# /m3 (air) to /cm3 (air))
	Cw = ((Cw*1.0e-6)/200.0)*si.N_A

	return DStar_org, mfp, accom_coeff, therm_sp, surfT, Cw, act_coeff